# Демо использования утилитарных типов

TypeScript предоставляет полторы дюжины полезных условных типов. Их применение позволяет не только сократить время на выписывание структуры интерфейсов, то и добавляет смысловой контекст для разработчика.

В различных приложениях пользователь новые записи в базе данных. Это может быть бизнес или игра, но в любом случае, часть сведений к записи добавляет сам сервер. Пользователь не заполняет данные о дате получения или обновления, это делает центральный сервер.

В своей основе утилитарные Pick и Omit являются проекциями. Например, вы могли бы самостоятельно реализовать Pick 

```ts
type MyPick<T, K extends keyof T> = {
  [k in K]:T[k]
}
```

Но вам этого делать не придется. В библиотеке типов TypeScript эти удобные типы уже подготовлены.

## Пример интерфейса и обсуждение вычисляемых полей

Мы обсудим использование утилитарных типов с целью донести до коллег сведения о происхождении типов (почти Ч. Дарвин). В прошлых демонстрациях, при необходимости уменьшить количество полей в ожидаемом аргументе мы определяли новый, ни с чем не связанный тип. Использование Pick, Omit  позволяет не только изменить количество полей, но и показать связь между используемыми в приложениями типами.

В интерфейсе `Message` пользователь может прочитать сведения о дате создания и дате прочтения сообщения. При создании нового сообщения пользователь заполняет не все поля. Приложение самостоятельно инициализирует идентификатор отправителя `from`, а поле - read для отправляемого сообщения не является актуальным.

Представим работу приложения по обмену сообщениями. Один из вариантов реализации хранения состояния такого приложения может быть выполнен в рамках идеологии redux.

Кстати, redux содержит необходимые TypeScript-у сведения о типах самом пакете npm.
